C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\obj\key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\key.c BROWSE INCDIR(.\inc;.\lib) DEBUG OBJECTEXTEND PRINT(.\list\key.ls
                    -t) TABS(2) OBJECT(.\obj\key.obj)

line level    source

   1          
   2          
   3          /*
   4           * key.c
   5           */
   6          
   7          #include <key.h>
   8          #include "inc\SC92F844x_C.h"
   9          #include "data_type.h"
  10          #include "lib\SensorMethod.h"
  11          #include "fan.h"
  12          #include "led.h"
  13          #include "eeprom.h"
  14          #include "filter.h"
  15          #include "ion.h"
  16          #include "arom.h"
  17          #include "timing_off.h"
  18          #include "beep.h"
  19          
  20          
  21          bitval key_flag;
  22          bitval key_flag2;
  23          
  24          #define KEY_POWER_FLAG  key_flag.bit0
  25          #define KEY_AROM_FLAG key_flag.bit1   
  26          #define KEY_SPEED_FLAG  key_flag.bit2
  27          #define KEY_LOCK_FLAG key_flag.bit3
  28          #define LOCK_FLAG   key_flag.bit6            //童锁解锁标志, 0解锁, 1锁住
  29          #define KEY_ION_FLAG key_flag.bit4
  30          #define KEY_TIMER_FLAG key_flag.bit5
  31          #define KEY_POWER_SPEED_FLAG key_flag.bit7
  32          
  33          #define KEY_POWER_SPEED_FLAG2 key_flag2.bit0 
  34          #define KEY_POWER_SHORT_FLAG key_flag2.bit1
  35          //按下电源和风速键后要等2个按键都释放在复位此位
  36          
  37          unsigned short key_power_count;
  38          unsigned short key_speed_count;
  39          unsigned short key_lock_count;
  40          unsigned short key_ion_count;
  41          unsigned short key_timer_count;
  42          unsigned short key_arom_count;
  43          unsigned short key_power_speed_count;
  44          
  45          unsigned long xdata key_no_move_count;      //按键没要按下计数, 如果一分钟没有动作,童锁就锁住
  46          
  47          
  48          INT32U exKeyValueFlag = 0;    //当前轮按键标志
  49          
  50          
  51          /**************************************************
  52          *函数名称：void  Sys_Scan(void) 
  53          *函数功能：扫描TK和显示
  54          *入口参数：void
C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 2   

  55          *出口参数：void  
  56          **************************************************/
  57          void Sys_Scan(void)
  58          {             
  59   1        if(SOCAPI_TouchKeyStatus&0x80)      //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标
             -志位置起后
  60   1         {                                      
  61   2          SOCAPI_TouchKeyStatus &= 0x7f;  //重要步骤3: 清除标志位， 需要外部清除。                              
  62   2          exKeyValueFlag = TouchKeyScan();//按键数据处理函数    
  63   2          if((exKeyValueFlag & 0x0000031e0) != 0)reset_key_no_move_count(); //有键按下就复位按键计数值
  64   2          TouchKeyRestart();        //启动下一轮转换                                                                  
  65   2        }          
  66   1      }
  67          
  68          void key_init(void)
  69          {
  70   1        LOCK_FLAG = 0;  
  71   1        reset_key_no_move_count();
  72   1      }
  73          
  74          void reset_key_no_move_count(void)
  75          {
  76   1        key_no_move_count = 0;
  77   1      }
  78          
  79          //0x0100--power
  80          //0x2000--香薰
  81          //0x1000--ion
  82          //0x0080--模式
  83          //0x0040--童锁
  84          //0x0020--timer
  85          //0x31e0
  86          
  87          void key_task(void)       
  88          //按键任务, 1ms调用一次
  89          { 
  90   1        if(key_no_move_count >= 180000)
  91   1        {
  92   2          LOCK_FLAG = 1; 
  93   2        }
  94   1        else
  95   1        {
  96   2          //reset_key_no_move_count();
  97   2          if(POWER_ON_STATUS == read_power_status())key_no_move_count++;
  98   2        }
  99   1      
 100   1        
 101   1      
 102   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000100) && (0 == KEY_POWER_SPEED_FLAG2)
 103   1          && (0 == LOCK_FLAG))//电源键  //灵敏度不够
 104   1        {
 105   2          if(0 == KEY_POWER_FLAG)
 106   2          {     
 107   3            if(++key_power_count >= 5000)
 108   3            {
 109   4              KEY_POWER_FLAG = 1;   
 110   4              key_power_long_com();
 111   4            }
 112   3          }
 113   2        }
 114   1        else 
 115   1        {
C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 3   

 116   2          //if((exKeyValueFlag & 0x0000031e0) != 0x000000180) 
 117   2          if((exKeyValueFlag & 0x0000031e0) == 0) 
 118   2          {
 119   3            if((key_power_count>50) && (key_power_count< 5000) )//&& ( 0 == KEY_POWER_SHORT_FLAG))
 120   3            {
 121   4              //KEY_POWER_SHORT_FLAG = 1;
 122   4              key_power_com();
 123   4            }
 124   3          }
 125   2          //if((exKeyValueFlag & 0x0000031e0) == 0x000000000) KEY_POWER_SHORT_FLAG = 0;
 126   2          KEY_POWER_FLAG = 0;
 127   2          key_power_count = 0;
 128   2          
 129   2        }
 130   1        
 131   1        
 132   1        
 133   1        if(read_power_status() == POWER_OFF_STATUS)return; //关机状态直接返回
 134   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000180) && (0 == LOCK_FLAG)
 135   1          && (0 ==KEY_AROM_FLAG) && (0 == KEY_ION_FLAG) && (0 == KEY_TIMER_FLAG)
 136   1          && (0 == KEY_LOCK_FLAG))
 137   1        //风速加电源按键
 138   1        {
 139   2          if(0 == KEY_POWER_SPEED_FLAG)
 140   2          {     
 141   3            if(++key_power_speed_count >= 50)
 142   3            {
 143   4              KEY_POWER_SPEED_FLAG = 1; 
 144   4              KEY_POWER_SPEED_FLAG2 = 1;
 145   4              key_power_speed_com();
 146   4            }
 147   3          }
 148   2        }
 149   1        else 
 150   1        {   
 151   2          if(((exKeyValueFlag & 0x000000180) == 0)) KEY_POWER_SPEED_FLAG2 = 0;
 152   2          KEY_POWER_SPEED_FLAG = 0;
 153   2          key_power_speed_count = 0;
 154   2        }
 155   1        
 156   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000080)&& (0 == KEY_POWER_SPEED_FLAG2)
 157   1          && (0 == LOCK_FLAG) )//风速键 
 158   1        {
 159   2          if(0 == KEY_SPEED_FLAG)
 160   2          {
 161   3            if(++key_speed_count >= 50)
 162   3            {
 163   4              KEY_SPEED_FLAG = 1;
 164   4              key_speed_com();
 165   4            }
 166   3          }
 167   2        }
 168   1        else 
 169   1        {
 170   2          if((exKeyValueFlag & 0x000000080) == 0)
 171   2          {
 172   3            KEY_SPEED_FLAG = 0;
 173   3            key_speed_count = 0;
 174   3          }
 175   2        }
 176   1        
 177   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000001000) && (0 == LOCK_FLAG))//ion
C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 4   

 178   1        {
 179   2          if(0 == KEY_ION_FLAG)
 180   2          {
 181   3            if(++key_ion_count >= 50)
 182   3            {
 183   4              KEY_ION_FLAG = 1;
 184   4              key_ion_com();        
 185   4            }
 186   3          }
 187   2        }
 188   1        else 
 189   1        {
 190   2          if((exKeyValueFlag & 0x000001000) == 0)
 191   2          {
 192   3            KEY_ION_FLAG = 0;
 193   3            key_ion_count = 0;
 194   3          }
 195   2        }
 196   1        
 197   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000002000) && (0 == LOCK_FLAG))//arom
 198   1        {
 199   2          if(0 == KEY_AROM_FLAG)
 200   2          {
 201   3            if(++key_arom_count >= 50)
 202   3            {
 203   4              KEY_AROM_FLAG = 1;
 204   4              key_arom_com();       
 205   4            }
 206   3          }
 207   2        }
 208   1        else 
 209   1        {
 210   2          if((exKeyValueFlag & 0x000002000) == 0)
 211   2          {
 212   3            KEY_AROM_FLAG = 0;
 213   3            key_arom_count = 0;
 214   3          }
 215   2        }
 216   1          
 217   1        if((exKeyValueFlag & 0x0000031e0) == 0x000000040)//
 218   1        {
 219   2          if(0 == KEY_LOCK_FLAG)
 220   2          {
 221   3            if(++key_lock_count >= 5000)
 222   3            {
 223   4              KEY_LOCK_FLAG = 1;
 224   4              //set_beep_count(10);
 225   4              key_lock_com();       
 226   4            }
 227   3          }
 228   2        }
 229   1        else 
 230   1        {
 231   2          if((exKeyValueFlag & 0x000000040) == 0x000000000)
 232   2          {
 233   3            KEY_LOCK_FLAG = 0;
 234   3            key_lock_count = 0;
 235   3          }
 236   2        }
 237   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000020) && (0 == LOCK_FLAG))//
 238   1        {
 239   2          if(0 == KEY_TIMER_FLAG)
C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 5   

 240   2          {
 241   3            if(++key_timer_count >= 50)
 242   3            {
 243   4              KEY_TIMER_FLAG = 1;
 244   4              key_timer_com();        
 245   4            }
 246   3          }
 247   2        }
 248   1        else 
 249   1        {
 250   2          if((exKeyValueFlag & 0x000000020) == 0x000000000)
 251   2          {
 252   3            KEY_TIMER_FLAG = 0;
 253   3            key_timer_count = 0;
 254   3          }
 255   2        }
 256   1      }
 257          
 258          void key_ion_com(void)
 259          {
 260   1        ION_PIN = !ION_PIN;
 261   1        set_beep_count(10);
 262   1        //fan_pulse_count_add();
 263   1      }
 264          
 265          void reset_lock_flag(void)
 266          {
 267   1        LOCK_FLAG = 0;
 268   1        reset_key_no_move_count();
 269   1        set_beep_count(10);
 270   1      }
 271          
 272          void key_timer_com(void)
 273          {
 274   1        regulate_timing_off_level();
 275   1        set_beep_count(10);
 276   1      }
 277          
 278          void key_arom_com(void)
 279          {
 280   1        regulate_arom_level();
 281   1        set_beep_count(10);
 282   1        //fan_pulse_count_dec();
 283   1      }
 284          
 285          void key_power_speed_com(void)
 286          {
 287   1        regulate_fan_speed();//速度加1
 288   1        write_speed_to_eeprom();//写入eeprom
 289   1        set_beep_count(10);
 290   1      }
 291          
 292          void key_lock_com(void)
 293          {
 294   1        //P52 = ~P52;
 295   1        //UNLOCk_FLAG = ~UNLOCk_FLAG;
 296   1        //LOCK_FLAG = ~LOCK_FLAG;      //解
 297   1        reset_lock_flag();  
 298   1        
 299   1      }
 300          unsigned char read_lock_flag(void)
 301          {
C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 6   

 302   1        return LOCK_FLAG;
 303   1      }
 304          
 305          void key_speed_com(void)
 306          {
 307   1        regulate_fan_speed();
 308   1        set_beep_count(10);
 309   1        
 310   1      }
 311          
 312          void key_power_long_com(void)
 313          //长按电源键清楚滤网寿命
 314          {
 315   1        reset_filter_time();
 316   1        set_beep_count(10);
 317   1      }
 318          
 319          //void key_sleep_com(void)
 320          //{ 
 321          //  P50 = ~P50;
 322          //  if(read_fan_speed() != 0) 
 323          //  {
 324          /////   set_fan_speed(0);
 325          //    //set_night_light_level(0);
 326          //    //led_key_sleep();
 327          //  }
 328          //  else 
 329          //  {
 330          ////    set_fan_speed(1);
 331          //    //led_key_speed();
 332          //  }
 333          //  
 334          //}
 335          
 336          
 337          
 338          void key_power_com(void)
 339          {
 340   1        //unsigned long filter_time_temp;
 341   1        //P50 = ~P50;
 342   1        set_beep_count(10);
 343   1        if(POWER_ON_STATUS == read_power_status())
 344   1        {
 345   2          power_off();
 346   2          //if((read_filter_time()) & 0x000000ff == 0) led_power_on();
 347   2          
 348   2          //filter_time_temp = read_filter_time();
 349   2          //WDTCON  = 0x10;
 350   2          //IAPWrite(0x0f,(unsigned char)(filter_time_temp & 0x000000ff),IapEPPROM); 
 351   2          //IAPWrite(0x0f,0x20,IapEPPROM); 
 352   2          //IAPWrite(0x0f,31,IapEPPROM); 
 353   2          write_filter_time();
 354   2        }
 355   1        else
 356   1        {
 357   2          power_on();
 358   2        }
 359   1      }
 360          
 361          


C51 COMPILER V9.52.0.0   KEY                                                               11/04/2019 23:02:06 PAGE 7   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    885    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
