C51 COMPILER V9.52.0.0   KEY                                                               11/01/2019 20:20:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\obj\key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\key.c BROWSE INCDIR(.\inc;.\lib) DEBUG OBJECTEXTEND PRINT(.\list\key.ls
                    -t) TABS(2) OBJECT(.\obj\key.obj)

line level    source

   1          
   2          
   3          /*
   4           * key.c
   5           */
   6          
   7          #include <key.h>
   8          #include "inc\SC92F844x_C.h"
   9          #include "data_type.h"
  10          #include "lib\SensorMethod.h"
  11          #include "fan.h"
  12          #include "led.h"
  13          #include "eeprom.h"
  14          #include "filter.h"
  15          #include "ion.h"
  16          #include "arom.h"
  17          #include "timing_off.h"
  18          #include "beep.h"
  19          
  20          
  21          bitval key_flag;
  22          bitval key_flag2;
  23          
  24          #define KEY_POWER_FLAG  key_flag.bit0
  25          #define KEY_AROM_FLAG key_flag.bit1   
  26          #define KEY_SPEED_FLAG  key_flag.bit2
  27          #define KEY_LOCK_FLAG key_flag.bit3
  28          #define LOCK_FLAG   key_flag.bit6            //童锁解锁标志, 0解锁, 1锁住
  29          #define KEY_ION_FLAG key_flag.bit4
  30          #define KEY_TIMER_FLAG key_flag.bit5
  31          #define KEY_POWER_SPEED_FLAG key_flag.bit7
  32          
  33          #define KEY_POWER_SPEED_FLAG2 key_flag2.bit0   
  34          //按下电源和风速键后要等2个按键都释放在复位此位
  35          
  36          unsigned short key_power_count;
  37          unsigned short key_speed_count;
  38          unsigned short key_lock_count;
  39          unsigned short key_ion_count;
  40          unsigned short key_timer_count;
  41          unsigned short key_arom_count;
  42          unsigned short key_power_speed_count;
  43          
  44          unsigned long xdata key_no_move_count;      //按键没要按下计数, 如果一分钟没有动作,童锁就锁住
  45          
  46          
  47          INT32U exKeyValueFlag = 0;    //当前轮按键标志
  48          
  49          
  50          /**************************************************
  51          *函数名称：void  Sys_Scan(void) 
  52          *函数功能：扫描TK和显示
  53          *入口参数：void
  54          *出口参数：void  
C51 COMPILER V9.52.0.0   KEY                                                               11/01/2019 20:20:49 PAGE 2   

  55          **************************************************/
  56          void Sys_Scan(void)
  57          {             
  58   1        if(SOCAPI_TouchKeyStatus&0x80)      //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标
             -志位置起后
  59   1         {                                      
  60   2          SOCAPI_TouchKeyStatus &= 0x7f;  //重要步骤3: 清除标志位， 需要外部清除。                              
  61   2          exKeyValueFlag = TouchKeyScan();//按键数据处理函数    
  62   2          if((exKeyValueFlag & 0x0000031e0) != 0)reset_key_no_move_count(); //有键按下就复位按键计数值
  63   2          TouchKeyRestart();        //启动下一轮转换                                                                  
  64   2        }          
  65   1      }
  66          
  67          void key_init(void)
  68          {
  69   1        LOCK_FLAG = 0;  
  70   1        reset_key_no_move_count();
  71   1      }
  72          
  73          void reset_key_no_move_count(void)
  74          {
  75   1        key_no_move_count = 0;
  76   1      }
  77          
  78          //0x0100--power
  79          //0x2000--香薰
  80          //0x1000--ion
  81          //0x0080--模式
  82          //0x0040--童锁
  83          //0x0020--timer
  84          //0x31e0
  85          
  86          void key_task(void)       
  87          //按键任务, 1ms调用一次
  88          { 
  89   1        if(key_no_move_count >= 180000)
  90   1        {
  91   2          LOCK_FLAG = 1; 
  92   2        }
  93   1        else
  94   1        {
  95   2          //reset_key_no_move_count();
  96   2          key_no_move_count++;
  97   2        }
  98   1      
  99   1        
 100   1      
 101   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000100) && (0 == KEY_POWER_SPEED_FLAG2)
 102   1          && (0 == LOCK_FLAG))//电源键  //灵敏度不够
 103   1        {
 104   2          if(0 == KEY_POWER_FLAG)
 105   2          {     
 106   3            if(++key_power_count >= 5000)
 107   3            {
 108   4              KEY_POWER_FLAG = 1;   
 109   4              key_power_long_com();
 110   4            }
 111   3          }
 112   2        }
 113   1        else 
 114   1        {
 115   2          if((exKeyValueFlag & 0x0000031e0) != 0x000000180) 
C51 COMPILER V9.52.0.0   KEY                                                               11/01/2019 20:20:49 PAGE 3   

 116   2          {
 117   3          if((key_power_count>50) && (key_power_count< 5000))
 118   3          {
 119   4            key_power_com();
 120   4          }
 121   3          }
 122   2          KEY_POWER_FLAG = 0;
 123   2          key_power_count = 0;
 124   2          
 125   2        }
 126   1        
 127   1        
 128   1        
 129   1        if(read_power_status() == POWER_OFF_STATUS)return; //关机状态直接返回
 130   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000180) && (0 == LOCK_FLAG))
 131   1        //风速加电源按键
 132   1        {
 133   2          if(0 == KEY_POWER_SPEED_FLAG)
 134   2          {     
 135   3            if(++key_power_speed_count >= 50)
 136   3            {
 137   4              KEY_POWER_SPEED_FLAG = 1; 
 138   4              KEY_POWER_SPEED_FLAG2 = 1;
 139   4              key_power_speed_com();
 140   4            }
 141   3          }
 142   2        }
 143   1        else 
 144   1        {   
 145   2          if(((exKeyValueFlag & 0x000000180) == 0)) KEY_POWER_SPEED_FLAG2 = 0;
 146   2          KEY_POWER_SPEED_FLAG = 0;
 147   2          key_power_speed_count = 0;
 148   2        }
 149   1        
 150   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000080)&& (0 == KEY_POWER_SPEED_FLAG2)
 151   1          && (0 == LOCK_FLAG))//风速键 
 152   1        {
 153   2          if(0 == KEY_SPEED_FLAG)
 154   2          {
 155   3            if(++key_speed_count >= 50)
 156   3            {
 157   4              KEY_SPEED_FLAG = 1;
 158   4              key_speed_com();
 159   4            }
 160   3          }
 161   2        }
 162   1        else 
 163   1        {
 164   2      //    if((key_speed_count>5) && (key_speed_count< 5000))
 165   2      //    {
 166   2      //      key_speed_com();
 167   2      //    }
 168   2          KEY_SPEED_FLAG = 0;
 169   2          key_speed_count = 0;
 170   2        }
 171   1        
 172   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000001000) && (0 == LOCK_FLAG))//ion
 173   1        {
 174   2          if(0 == KEY_ION_FLAG)
 175   2          {
 176   3            if(++key_ion_count >= 50)
 177   3            {
C51 COMPILER V9.52.0.0   KEY                                                               11/01/2019 20:20:49 PAGE 4   

 178   4              KEY_ION_FLAG = 1;
 179   4              key_ion_com();        
 180   4            }
 181   3          }
 182   2        }
 183   1        else 
 184   1        {
 185   2          KEY_ION_FLAG = 0;
 186   2          key_ion_count = 0;
 187   2        }
 188   1        
 189   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000002000) && (0 == LOCK_FLAG))//arom
 190   1        {
 191   2          if(0 == KEY_AROM_FLAG)
 192   2          {
 193   3            if(++key_arom_count >= 50)
 194   3            {
 195   4              KEY_AROM_FLAG = 1;
 196   4              key_arom_com();       
 197   4            }
 198   3          }
 199   2        }
 200   1        else 
 201   1        {
 202   2          KEY_AROM_FLAG = 0;
 203   2          key_arom_count = 0;
 204   2        }
 205   1          
 206   1        if((exKeyValueFlag & 0x0000031e0) == 0x000000040)//
 207   1        {
 208   2          if(0 == KEY_LOCK_FLAG)
 209   2          {
 210   3            if(++key_lock_count >= 5000)
 211   3            {
 212   4              KEY_LOCK_FLAG = 1;
 213   4              //set_beep_count(10);
 214   4              key_lock_com();       
 215   4            }
 216   3          }
 217   2        }
 218   1        else 
 219   1        {
 220   2          KEY_LOCK_FLAG = 0;
 221   2          key_lock_count = 0;
 222   2        }
 223   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000020) && (0 == LOCK_FLAG))//
 224   1        {
 225   2          if(0 == KEY_TIMER_FLAG)
 226   2          {
 227   3            if(++key_timer_count >= 50)
 228   3            {
 229   4              KEY_TIMER_FLAG = 1;
 230   4              key_timer_com();        
 231   4            }
 232   3          }
 233   2        }
 234   1        else 
 235   1        {
 236   2          KEY_TIMER_FLAG = 0;
 237   2          key_timer_count = 0;
 238   2        }
 239   1      }
C51 COMPILER V9.52.0.0   KEY                                                               11/01/2019 20:20:49 PAGE 5   

 240          
 241          void key_ion_com(void)
 242          {
 243   1        ION_PIN = !ION_PIN;
 244   1        set_beep_count(10);
 245   1        //fan_pulse_count_add();
 246   1      }
 247          
 248          void reset_lock_flag(void)
 249          {
 250   1        LOCK_FLAG = 0;
 251   1        reset_key_no_move_count();
 252   1        set_beep_count(10);
 253   1      }
 254          
 255          void key_timer_com(void)
 256          {
 257   1        regulate_timing_off_level();
 258   1        set_beep_count(10);
 259   1      }
 260          
 261          void key_arom_com(void)
 262          {
 263   1        regulate_arom_level();
 264   1        set_beep_count(10);
 265   1        //fan_pulse_count_dec();
 266   1      }
 267          
 268          void key_power_speed_com(void)
 269          {
 270   1        regulate_fan_speed();//速度加1
 271   1        write_speed_to_eeprom();//写入eeprom
 272   1        set_beep_count(10);
 273   1      }
 274          
 275          void key_lock_com(void)
 276          {
 277   1        //P52 = ~P52;
 278   1        //UNLOCk_FLAG = ~UNLOCk_FLAG;
 279   1        //LOCK_FLAG = ~LOCK_FLAG;      //解
 280   1        reset_lock_flag();  
 281   1        
 282   1      }
 283          unsigned char read_lock_flag(void)
 284          {
 285   1        return LOCK_FLAG;
 286   1      }
 287          
 288          void key_speed_com(void)
 289          {
 290   1        regulate_fan_speed();
 291   1        set_beep_count(10);
 292   1        
 293   1      }
 294          
 295          void key_power_long_com(void)
 296          //长按电源键清楚滤网寿命
 297          {
 298   1        reset_filter_time();
 299   1        set_beep_count(10);
 300   1      }
 301          
C51 COMPILER V9.52.0.0   KEY                                                               11/01/2019 20:20:49 PAGE 6   

 302          //void key_sleep_com(void)
 303          //{ 
 304          //  P50 = ~P50;
 305          //  if(read_fan_speed() != 0) 
 306          //  {
 307          /////   set_fan_speed(0);
 308          //    //set_night_light_level(0);
 309          //    //led_key_sleep();
 310          //  }
 311          //  else 
 312          //  {
 313          ////    set_fan_speed(1);
 314          //    //led_key_speed();
 315          //  }
 316          //  
 317          //}
 318          
 319          
 320          
 321          void key_power_com(void)
 322          {
 323   1        //unsigned long filter_time_temp;
 324   1        //P50 = ~P50;
 325   1        set_beep_count(10);
 326   1        if(POWER_ON_STATUS == read_power_status())
 327   1        {
 328   2          power_off();
 329   2          //if((read_filter_time()) & 0x000000ff == 0) led_power_on();
 330   2          
 331   2          //filter_time_temp = read_filter_time();
 332   2          //WDTCON  = 0x10;
 333   2          //IAPWrite(0x0f,(unsigned char)(filter_time_temp & 0x000000ff),IapEPPROM); 
 334   2          //IAPWrite(0x0f,0x20,IapEPPROM); 
 335   2          //IAPWrite(0x0f,31,IapEPPROM); 
 336   2          write_filter_time();
 337   2        }
 338   1        else
 339   1        {
 340   2          power_on();
 341   2        }
 342   1      }
 343          
 344          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    777    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
