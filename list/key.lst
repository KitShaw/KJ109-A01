C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\obj\key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\key.c BROWSE INCDIR(.\inc;.\lib) DEBUG OBJECTEXTEND PRINT(.\list\key.ls
                    -t) TABS(2) OBJECT(.\obj\key.obj)

line level    source

   1          
   2          
   3          /*
   4           * key.c
   5           */
   6          
   7          #include <key.h>
   8          #include "inc\SC92F844x_C.h"
   9          #include "data_type.h"
  10          #include "lib\SensorMethod.h"
  11          #include "fan.h"
  12          #include "led.h"
  13          #include "eeprom.h"
  14          #include "filter.h"
  15          #include "ion.h"
  16          #include "arom.h"
  17          #include "timing_off.h"
  18          #include "beep.h"
  19          
  20          
  21          bitval key_flag;
  22          bitval key_flag2;
  23          
  24          #define KEY_POWER_FLAG  key_flag.bit0
  25          #define KEY_AROM_FLAG key_flag.bit1   
  26          #define KEY_SPEED_FLAG  key_flag.bit2
  27          #define KEY_LOCK_FLAG key_flag.bit3
  28          #define LOCK_FLAG   key_flag.bit6            //童锁解锁标志, 0解锁, 1锁住
  29          #define KEY_ION_FLAG key_flag.bit4
  30          #define KEY_TIMER_FLAG key_flag.bit5
  31          #define KEY_POWER_SPEED_FLAG key_flag.bit7
  32          
  33          #define KEY_POWER_SPEED_FLAG2 key_flag2.bit0 
  34          #define KEY_POWER_SHORT_FLAG key_flag2.bit1
  35          #define KEY_SPEED_TIMER_FLAG key_flag2.bit2
  36          #define KEY_SPEED_AROM_FLAG key_flag2.bit3
  37          #define KEY_POWER_AROM_FLAG key_flag2.bit4
  38          #define KEY_POWER_AROM_FLAG2 key_flag2.bit5
  39          #define KEY_POWER_ION_FLAG key_flag2.bit6
  40          #define KEY_POWER_ION_FLAG2 key_flag2.bit7
  41          
  42          
  43          
  44          
  45          //按下电源和风速键后要等2个按键都释放在复位此位
  46          
  47          unsigned short key_speed_arom_count;
  48          unsigned short key_speed_timer_count;
  49          unsigned short key_power_count;
  50          unsigned short key_speed_count;
  51          unsigned short key_lock_count;
  52          unsigned short key_ion_count;
  53          unsigned short key_timer_count;
  54          unsigned short key_arom_count;
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 2   

  55          unsigned short key_power_speed_count;
  56          unsigned short key_power_ion_count;
  57          unsigned short key_power_arom_count;
  58          unsigned short power_up_20s_count;  //上电20s计数, 20秒内可以查看版本号
  59          
  60          unsigned long xdata key_no_move_count;      //按键没要按下计数, 如果一分钟没有动作,童锁就锁住
  61          
  62          
  63          INT32U exKeyValueFlag = 0;    //当前轮按键标志
  64          
  65          
  66          /**************************************************
  67          *函数名称：void  Sys_Scan(void) 
  68          *函数功能：扫描TK和显示
  69          *入口参数：void
  70          *出口参数：void  
  71          **************************************************/
  72          void Sys_Scan(void)
  73          {             
  74   1        if(SOCAPI_TouchKeyStatus&0x80)      //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标
             -志位置起后
  75   1         {                                      
  76   2          SOCAPI_TouchKeyStatus &= 0x7f;  //重要步骤3: 清除标志位， 需要外部清除。                              
  77   2          exKeyValueFlag = TouchKeyScan();//按键数据处理函数    
  78   2          if((exKeyValueFlag & 0x0000031e0) != 0)reset_key_no_move_count(); //有键按下就复位按键计数值
  79   2          TouchKeyRestart();        //启动下一轮转换                                                                  
  80   2        }          
  81   1      }
  82          
  83          void key_init(void)
  84          {
  85   1        LOCK_FLAG = 0;  
  86   1        reset_key_no_move_count();
  87   1        //KEY_AROM_SPEED_TIMER_FLAG = 0;
  88   1        KEY_POWER_FLAG = 0;
  89   1        KEY_AROM_FLAG = 0;
  90   1        KEY_SPEED_FLAG = 0;
  91   1        KEY_LOCK_FLAG = 0;
  92   1        LOCK_FLAG = 0;            //童锁解锁标志, 0解锁, 1锁住
  93   1        KEY_ION_FLAG = 0;
  94   1        KEY_TIMER_FLAG = 0;
  95   1        KEY_POWER_SPEED_FLAG = 0;
  96   1        KEY_POWER_SPEED_FLAG2  = 0;
  97   1        KEY_POWER_SHORT_FLAG = 0;
  98   1        KEY_SPEED_TIMER_FLAG = 0;
  99   1        power_up_20s_count = 0;
 100   1      }
 101          
 102          void reset_key_no_move_count(void)
 103          {
 104   1        key_no_move_count = 0;
 105   1      }
 106          
 107          //0x0100--power
 108          //0x2000--香薰
 109          //0x1000--ion
 110          //0x0080--模式
 111          //0x0040--童锁
 112          //0x0020--timer
 113          //0x31e0
 114          
 115          void key_task(void)       
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 3   

 116          //按键任务, 1ms调用一次
 117          { 
 118   1        if(key_no_move_count >= 180000)
 119   1        {
 120   2          LOCK_FLAG = 1; 
 121   2        }
 122   1        else
 123   1        {
 124   2          //reset_key_no_move_count();
 125   2          if(POWER_ON_STATUS == read_power_status())key_no_move_count++;
 126   2        }
 127   1        
 128   1      
 129   1        
 130   1      
 131   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000100) && (0 == KEY_POWER_SPEED_FLAG2)    
 132   1          && (0 == KEY_POWER_ION_FLAG2) && (0 == KEY_POWER_AROM_FLAG2) && (0 == LOCK_FLAG))//电源键  //灵敏度不够
 133   1        {
 134   2          if(0 == KEY_POWER_FLAG)
 135   2          {     
 136   3            if(++key_power_count >= 5000)
 137   3            {
 138   4              KEY_POWER_FLAG = 1;   
 139   4              key_power_long_com();
 140   4            }
 141   3          }
 142   2        }
 143   1        else 
 144   1        {
 145   2          //if((exKeyValueFlag & 0x0000031e0) != 0x000000180) 
 146   2          if((exKeyValueFlag & 0x0000031e0) == 0) 
 147   2          {
 148   3            if((key_power_count>50) && (key_power_count< 5000) )//&& ( 0 == KEY_POWER_SHORT_FLAG))
 149   3            {
 150   4              //KEY_POWER_SHORT_FLAG = 1;
 151   4              key_power_com();
 152   4            }
 153   3          }
 154   2          //if((exKeyValueFlag & 0x0000031e0) == 0x000000000) KEY_POWER_SHORT_FLAG = 0;
 155   2          KEY_POWER_FLAG = 0;
 156   2          key_power_count = 0;    
 157   2        }
 158   1        
 159   1        if(power_up_20s_count < 20000) power_up_20s_count++;
 160   1        
 161   1        if(read_power_status() == POWER_OFF_STATUS)
 162   1        {
 163   2          if(((exKeyValueFlag & 0x0000031e0) == 0x0000002080) )  //80(s 2000a 20t
 164   2          {
 165   3            if(0 == KEY_SPEED_AROM_FLAG)
 166   3            {
 167   4              if(++key_speed_arom_count >= 5000)
 168   4                //显示软件版本号
 169   4              {
 170   5                KEY_SPEED_AROM_FLAG = 1;
 171   5                chang_init_up_power();  //改变上电初始状态
 172   5              }
 173   4            }     
 174   3          }
 175   2          else
 176   2          {
 177   3            key_speed_arom_count = 0;
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 4   

 178   3            KEY_SPEED_AROM_FLAG = 0;
 179   3          }
 180   2      
 181   2          if(((exKeyValueFlag & 0x0000031e0) == 0x0000000a0) && (power_up_20s_count<20000))  //80(s 2000a 20t
 182   2          {
 183   3            if(0 == KEY_SPEED_TIMER_FLAG)
 184   3            {
 185   4              if(++key_speed_timer_count >= 15000)
 186   4                //显示软件版本号
 187   4              {
 188   5                KEY_SPEED_TIMER_FLAG = 1;
 189   5                led_display_version();
 190   5              }
 191   4            }
 192   3            
 193   3          }
 194   2          
 195   2          return; //关机状态直接返回
 196   2        }
 197   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000180) && (0 == LOCK_FLAG))
 198   1        //风速加电源按键
 199   1        {
 200   2          if(0 == KEY_POWER_SPEED_FLAG)
 201   2          {     
 202   3            if(++key_power_speed_count >= 50)
 203   3            {
 204   4              KEY_POWER_SPEED_FLAG = 1; 
 205   4              KEY_POWER_SPEED_FLAG2 = 1;
 206   4              key_power_speed_com();
 207   4            }
 208   3          }
 209   2        }
 210   1        else 
 211   1        {   
 212   2          if(((exKeyValueFlag & 0x000000180) == 0)) KEY_POWER_SPEED_FLAG2 = 0;
 213   2          KEY_POWER_SPEED_FLAG = 0;
 214   2          key_power_speed_count = 0;
 215   2        }
 216   1      
 217   1        
 218   1        
 219   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000080)&& (0 == KEY_POWER_SPEED_FLAG2)
 220   1          && (0 == LOCK_FLAG) )//风速键 
 221   1        {
 222   2          if(0 == KEY_SPEED_FLAG)
 223   2          {
 224   3            if(++key_speed_count >= 50)
 225   3            {
 226   4              KEY_SPEED_FLAG = 1;
 227   4              key_speed_com();
 228   4            }
 229   3          }
 230   2        }
 231   1        else 
 232   1        {
 233   2          if((exKeyValueFlag & 0x000000080) == 0)
 234   2          {
 235   3            KEY_SPEED_FLAG = 0;
 236   3            key_speed_count = 0;
 237   3          }
 238   2        }
 239   1      
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 5   

 240   1        if(((exKeyValueFlag & 0x0000031e0) == 0x0000001100) && (0 == LOCK_FLAG))
 241   1        //电源按键加负离子
 242   1        {
 243   2          if(0 == KEY_POWER_ION_FLAG)
 244   2          {     
 245   3            if(++key_power_ion_count >= 50)
 246   3            {
 247   4              KEY_POWER_ION_FLAG = 1; 
 248   4              KEY_POWER_ION_FLAG2 = 1;
 249   4              write_ion_to_eeprom();
 250   4              set_beep_count(10);
 251   4              //key_power_speed_com();
 252   4            }
 253   3          }
 254   2        }
 255   1        else 
 256   1        {   
 257   2          if(((exKeyValueFlag & 0x0000001100) == 0)) KEY_POWER_ION_FLAG2 = 0;
 258   2          KEY_POWER_ION_FLAG = 0;
 259   2          key_power_ion_count = 0;
 260   2        }
 261   1        
 262   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000001000) && (0 == KEY_POWER_ION_FLAG2)
 263   1          && (0 == LOCK_FLAG))//ion
 264   1        {
 265   2          if(0 == KEY_ION_FLAG)
 266   2          {
 267   3            if(++key_ion_count >= 50)
 268   3            {
 269   4              KEY_ION_FLAG = 1;
 270   4              key_ion_com();        
 271   4            }
 272   3          }
 273   2        }
 274   1        else 
 275   1        {
 276   2          if((exKeyValueFlag & 0x000001000) == 0)
 277   2          {
 278   3            KEY_ION_FLAG = 0;
 279   3            key_ion_count = 0;
 280   3          }
 281   2        }
 282   1      
 283   1      
 284   1        if(((exKeyValueFlag & 0x0000031e0) == 0x0000002100) && (0 == LOCK_FLAG))
 285   1        //电源按键加香薰
 286   1        {
 287   2          if(0 == KEY_POWER_AROM_FLAG)
 288   2          {     
 289   3            if(++key_power_arom_count >= 50)
 290   3            {
 291   4              KEY_POWER_AROM_FLAG = 1;  
 292   4              KEY_POWER_AROM_FLAG2 = 1;
 293   4              //write_ion_to_eeprom();        
 294   4              key_power_arom_com();
 295   4            }
 296   3          }
 297   2        }
 298   1        else 
 299   1        {   
 300   2          if(((exKeyValueFlag & 0x0000002100) == 0)) KEY_POWER_AROM_FLAG2 = 0;
 301   2          KEY_POWER_AROM_FLAG = 0;
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 6   

 302   2          key_power_arom_count = 0;
 303   2        }
 304   1        
 305   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000002000) && (0 == KEY_POWER_AROM_FLAG2)
 306   1          && (0 == LOCK_FLAG))//arom
 307   1        {
 308   2          if(0 == KEY_AROM_FLAG)
 309   2          {
 310   3            if(++key_arom_count >= 50)
 311   3            {
 312   4              KEY_AROM_FLAG = 1;
 313   4              key_arom_com();       
 314   4            }
 315   3          }
 316   2        }
 317   1        else 
 318   1        {
 319   2          if((exKeyValueFlag & 0x000002000) == 0)
 320   2          {
 321   3            KEY_AROM_FLAG = 0;
 322   3            key_arom_count = 0;
 323   3          }
 324   2        }
 325   1          
 326   1        if((exKeyValueFlag & 0x0000031e0) == 0x000000040)//
 327   1        {
 328   2          if(0 == KEY_LOCK_FLAG)
 329   2          {
 330   3            if(++key_lock_count >= 3000)
 331   3            {
 332   4              KEY_LOCK_FLAG = 1;
 333   4              //set_beep_count(10);
 334   4              key_lock_com();       
 335   4            }
 336   3          }
 337   2        }
 338   1        else 
 339   1        {
 340   2          if((exKeyValueFlag & 0x000000040) == 0x000000000)
 341   2          {
 342   3            KEY_LOCK_FLAG = 0;
 343   3            key_lock_count = 0;
 344   3          }
 345   2        }
 346   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000020) && (0 == LOCK_FLAG))//
 347   1        {
 348   2          if(0 == KEY_TIMER_FLAG)
 349   2          {
 350   3            if(++key_timer_count >= 50)
 351   3            {
 352   4              KEY_TIMER_FLAG = 1;
 353   4              key_timer_com();        
 354   4            }
 355   3          }
 356   2        }
 357   1        else 
 358   1        {
 359   2          if((exKeyValueFlag & 0x000000020) == 0x000000000)
 360   2          {
 361   3            KEY_TIMER_FLAG = 0;
 362   3            key_timer_count = 0;
 363   3          }
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 7   

 364   2        }
 365   1      }
 366          
 367          void key_ion_com(void)
 368          {
 369   1        ION_PIN = !ION_PIN;
 370   1        set_beep_count(10);
 371   1        //fan_pulse_count_add();
 372   1      }
 373          
 374          void reset_lock_flag(void)
 375          {
 376   1        LOCK_FLAG = 0;
 377   1        reset_key_no_move_count();
 378   1        set_beep_count(10);
 379   1      }
 380          
 381          void key_timer_com(void)
 382          {
 383   1        regulate_timing_off_level();
 384   1        set_beep_count(10);
 385   1      }
 386          
 387          void key_arom_com(void)
 388          {
 389   1        regulate_arom_level();
 390   1        set_beep_count(10);
 391   1        //fan_pulse_count_dec();
 392   1      }
 393          
 394          void key_power_speed_com(void)
 395          {
 396   1        regulate_fan_speed();//速度加1
 397   1        write_speed_to_eeprom();//写入eeprom
 398   1        set_beep_count(10);
 399   1      }
 400          
 401          void key_power_arom_com(void)
 402          {
 403   1        regulate_arom_level();
 404   1        write_arom_level_to_eeprom();
 405   1        set_beep_count(10);
 406   1      }
 407          
 408          void key_lock_com(void)
 409          {
 410   1        //P52 = ~P52;
 411   1        //UNLOCk_FLAG = ~UNLOCk_FLAG;
 412   1        //LOCK_FLAG = ~LOCK_FLAG;      //解
 413   1        reset_lock_flag();  
 414   1        
 415   1      }
 416          unsigned char read_lock_flag(void)
 417          {
 418   1        return LOCK_FLAG;
 419   1      }
 420          
 421          void key_speed_com(void)
 422          {
 423   1        regulate_fan_speed();
 424   1        set_beep_count(10);
 425   1        
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 8   

 426   1      }
 427          
 428          void key_power_long_com(void)
 429          //长按电源键清楚滤网寿命
 430          {
 431   1        reset_filter_time();
 432   1        set_beep_count(10);
 433   1      }
 434          
 435          //void key_sleep_com(void)
 436          //{ 
 437          //  P50 = ~P50;
 438          //  if(read_fan_speed() != 0) 
 439          //  {
 440          /////   set_fan_speed(0);
 441          //    //set_night_light_level(0);
 442          //    //led_key_sleep();
 443          //  }
 444          //  else 
 445          //  {
 446          ////    set_fan_speed(1);
 447          //    //led_key_speed();
 448          //  }
 449          //  
 450          //}
 451          
 452          
 453          
 454          void key_power_com(void)
 455          {
 456   1        //unsigned long filter_time_temp;
 457   1        //P50 = ~P50;
 458   1        set_beep_count(10);
 459   1        if(POWER_ON_STATUS == read_power_status())
 460   1        {
 461   2          power_off();
 462   2          //if((read_filter_time()) & 0x000000ff == 0) led_power_on();
 463   2          
 464   2          //filter_time_temp = read_filter_time();
 465   2          //WDTCON  = 0x10;
 466   2          //IAPWrite(0x0f,(unsigned char)(filter_time_temp & 0x000000ff),IapEPPROM); 
 467   2          //IAPWrite(0x0f,0x20,IapEPPROM); 
 468   2          //IAPWrite(0x0f,31,IapEPPROM); 
 469   2          write_filter_time();
 470   2        }
 471   1        else
 472   1        {
 473   2          power_on();
 474   2        }
 475   1      }
 476          
 477          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1287    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.52.0.0   KEY                                                               12/04/2019 21:16:54 PAGE 9   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
