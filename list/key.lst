C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\obj\key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\key.c BROWSE INCDIR(.\inc;.\lib) DEBUG OBJECTEXTEND PRINT(.\list\key.ls
                    -t) TABS(2) OBJECT(.\obj\key.obj)

line level    source

   1          
   2          
   3          /*
   4           * key.c
   5           */
   6          
   7          #include <key.h>
   8          #include "inc\SC92F844x_C.h"
   9          #include "data_type.h"
  10          #include "lib\SensorMethod.h"
  11          #include "fan.h"
  12          #include "led.h"
  13          #include "eeprom.h"
  14          #include "filter.h"
  15          #include "ion.h"
  16          #include "arom.h"
  17          #include "timing_off.h"
  18          #include "beep.h"
  19          
  20          
  21          bitval key_flag;
  22          bitval key_flag2;
  23          
  24          #define KEY_POWER_FLAG  key_flag.bit0
  25          #define KEY_AROM_FLAG key_flag.bit1   
  26          #define KEY_SPEED_FLAG  key_flag.bit2
  27          #define KEY_LOCK_FLAG key_flag.bit3
  28          #define LOCK_FLAG   key_flag.bit6            //童锁解锁标志, 0解锁, 1锁住
  29          #define KEY_ION_FLAG key_flag.bit4
  30          #define KEY_TIMER_FLAG key_flag.bit5
  31          #define KEY_POWER_SPEED_FLAG key_flag.bit7
  32          
  33          #define KEY_POWER_SPEED_FLAG2 key_flag2.bit0 
  34          #define KEY_POWER_SHORT_FLAG key_flag2.bit1
  35          #define KEY_SPEED_TIMER_FLAG key_flag2.bit2
  36          //按下电源和风速键后要等2个按键都释放在复位此位
  37          
  38          unsigned short key_speed_timer_count;
  39          unsigned short key_power_count;
  40          unsigned short key_speed_count;
  41          unsigned short key_lock_count;
  42          unsigned short key_ion_count;
  43          unsigned short key_timer_count;
  44          unsigned short key_arom_count;
  45          unsigned short key_power_speed_count;
  46          unsigned short power_up_20s_count;  //上电20s计数, 20秒内可以查看版本号
  47          
  48          unsigned long xdata key_no_move_count;      //按键没要按下计数, 如果一分钟没有动作,童锁就锁住
  49          
  50          
  51          INT32U exKeyValueFlag = 0;    //当前轮按键标志
  52          
  53          
  54          /**************************************************
C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 2   

  55          *函数名称：void  Sys_Scan(void) 
  56          *函数功能：扫描TK和显示
  57          *入口参数：void
  58          *出口参数：void  
  59          **************************************************/
  60          void Sys_Scan(void)
  61          {             
  62   1        if(SOCAPI_TouchKeyStatus&0x80)      //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标
             -志位置起后
  63   1         {                                      
  64   2          SOCAPI_TouchKeyStatus &= 0x7f;  //重要步骤3: 清除标志位， 需要外部清除。                              
  65   2          exKeyValueFlag = TouchKeyScan();//按键数据处理函数    
  66   2          if((exKeyValueFlag & 0x0000031e0) != 0)reset_key_no_move_count(); //有键按下就复位按键计数值
  67   2          TouchKeyRestart();        //启动下一轮转换                                                                  
  68   2        }          
  69   1      }
  70          
  71          void key_init(void)
  72          {
  73   1        LOCK_FLAG = 0;  
  74   1        reset_key_no_move_count();
  75   1        //KEY_AROM_SPEED_TIMER_FLAG = 0;
  76   1        KEY_POWER_FLAG = 0;
  77   1        KEY_AROM_FLAG = 0;
  78   1        KEY_SPEED_FLAG = 0;
  79   1        KEY_LOCK_FLAG = 0;
  80   1        LOCK_FLAG = 0;            //童锁解锁标志, 0解锁, 1锁住
  81   1        KEY_ION_FLAG = 0;
  82   1        KEY_TIMER_FLAG = 0;
  83   1        KEY_POWER_SPEED_FLAG = 0;
  84   1        KEY_POWER_SPEED_FLAG2  = 0;
  85   1        KEY_POWER_SHORT_FLAG = 0;
  86   1        KEY_SPEED_TIMER_FLAG = 0;
  87   1        power_up_20s_count = 0;
  88   1      }
  89          
  90          void reset_key_no_move_count(void)
  91          {
  92   1        key_no_move_count = 0;
  93   1      }
  94          
  95          //0x0100--power
  96          //0x2000--香薰
  97          //0x1000--ion
  98          //0x0080--模式
  99          //0x0040--童锁
 100          //0x0020--timer
 101          //0x31e0
 102          
 103          void key_task(void)       
 104          //按键任务, 1ms调用一次
 105          { 
 106   1        if(key_no_move_count >= 180000)
 107   1        {
 108   2          LOCK_FLAG = 1; 
 109   2        }
 110   1        else
 111   1        {
 112   2          //reset_key_no_move_count();
 113   2          if(POWER_ON_STATUS == read_power_status())key_no_move_count++;
 114   2        }
 115   1        
C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 3   

 116   1      
 117   1        
 118   1      
 119   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000100) && (0 == KEY_POWER_SPEED_FLAG2)
 120   1          && (0 == LOCK_FLAG))//电源键  //灵敏度不够
 121   1        {
 122   2          if(0 == KEY_POWER_FLAG)
 123   2          {     
 124   3            if(++key_power_count >= 5000)
 125   3            {
 126   4              KEY_POWER_FLAG = 1;   
 127   4              key_power_long_com();
 128   4            }
 129   3          }
 130   2        }
 131   1        else 
 132   1        {
 133   2          //if((exKeyValueFlag & 0x0000031e0) != 0x000000180) 
 134   2          if((exKeyValueFlag & 0x0000031e0) == 0) 
 135   2          {
 136   3            if((key_power_count>50) && (key_power_count< 5000) )//&& ( 0 == KEY_POWER_SHORT_FLAG))
 137   3            {
 138   4              //KEY_POWER_SHORT_FLAG = 1;
 139   4              key_power_com();
 140   4            }
 141   3          }
 142   2          //if((exKeyValueFlag & 0x0000031e0) == 0x000000000) KEY_POWER_SHORT_FLAG = 0;
 143   2          KEY_POWER_FLAG = 0;
 144   2          key_power_count = 0;
 145   2          
 146   2        }
 147   1        
 148   1        if(power_up_20s_count < 20000) power_up_20s_count++;
 149   1        
 150   1        if(read_power_status() == POWER_OFF_STATUS)
 151   1        {
 152   2          if((exKeyValueFlag & 0x0000031e0) == 0x0000000a0)  //80(s 2000a 20t
 153   2          {
 154   3            if(0 == KEY_SPEED_TIMER_FLAG)
 155   3            {
 156   4              if(++key_speed_timer_count >= 15000)
 157   4                //显示软件版本号
 158   4              {
 159   5                KEY_SPEED_TIMER_FLAG = 1;
 160   5                led_display_version();
 161   5              }
 162   4            }
 163   3            
 164   3          }
 165   2          return; //关机状态直接返回
 166   2        }
 167   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000180) && (0 == LOCK_FLAG))
 168   1        //风速加电源按键
 169   1        {
 170   2          if(0 == KEY_POWER_SPEED_FLAG)
 171   2          {     
 172   3            if(++key_power_speed_count >= 50)
 173   3            {
 174   4              KEY_POWER_SPEED_FLAG = 1; 
 175   4              KEY_POWER_SPEED_FLAG2 = 1;
 176   4              key_power_speed_com();
 177   4            }
C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 4   

 178   3          }
 179   2        }
 180   1        else 
 181   1        {   
 182   2          if(((exKeyValueFlag & 0x000000180) == 0)) KEY_POWER_SPEED_FLAG2 = 0;
 183   2          KEY_POWER_SPEED_FLAG = 0;
 184   2          key_power_speed_count = 0;
 185   2        }
 186   1        
 187   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000080)&& (0 == KEY_POWER_SPEED_FLAG2)
 188   1          && (0 == LOCK_FLAG) )//风速键 
 189   1        {
 190   2          if(0 == KEY_SPEED_FLAG)
 191   2          {
 192   3            if(++key_speed_count >= 50)
 193   3            {
 194   4              KEY_SPEED_FLAG = 1;
 195   4              key_speed_com();
 196   4            }
 197   3          }
 198   2        }
 199   1        else 
 200   1        {
 201   2          if((exKeyValueFlag & 0x000000080) == 0)
 202   2          {
 203   3            KEY_SPEED_FLAG = 0;
 204   3            key_speed_count = 0;
 205   3          }
 206   2        }
 207   1        
 208   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000001000) && (0 == LOCK_FLAG))//ion
 209   1        {
 210   2          if(0 == KEY_ION_FLAG)
 211   2          {
 212   3            if(++key_ion_count >= 50)
 213   3            {
 214   4              KEY_ION_FLAG = 1;
 215   4              key_ion_com();        
 216   4            }
 217   3          }
 218   2        }
 219   1        else 
 220   1        {
 221   2          if((exKeyValueFlag & 0x000001000) == 0)
 222   2          {
 223   3            KEY_ION_FLAG = 0;
 224   3            key_ion_count = 0;
 225   3          }
 226   2        }
 227   1        
 228   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000002000) && (0 == LOCK_FLAG))//arom
 229   1        {
 230   2          if(0 == KEY_AROM_FLAG)
 231   2          {
 232   3            if(++key_arom_count >= 50)
 233   3            {
 234   4              KEY_AROM_FLAG = 1;
 235   4              key_arom_com();       
 236   4            }
 237   3          }
 238   2        }
 239   1        else 
C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 5   

 240   1        {
 241   2          if((exKeyValueFlag & 0x000002000) == 0)
 242   2          {
 243   3            KEY_AROM_FLAG = 0;
 244   3            key_arom_count = 0;
 245   3          }
 246   2        }
 247   1          
 248   1        if((exKeyValueFlag & 0x0000031e0) == 0x000000040)//
 249   1        {
 250   2          if(0 == KEY_LOCK_FLAG)
 251   2          {
 252   3            if(++key_lock_count >= 5000)
 253   3            {
 254   4              KEY_LOCK_FLAG = 1;
 255   4              //set_beep_count(10);
 256   4              key_lock_com();       
 257   4            }
 258   3          }
 259   2        }
 260   1        else 
 261   1        {
 262   2          if((exKeyValueFlag & 0x000000040) == 0x000000000)
 263   2          {
 264   3            KEY_LOCK_FLAG = 0;
 265   3            key_lock_count = 0;
 266   3          }
 267   2        }
 268   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000020) && (0 == LOCK_FLAG))//
 269   1        {
 270   2          if(0 == KEY_TIMER_FLAG)
 271   2          {
 272   3            if(++key_timer_count >= 50)
 273   3            {
 274   4              KEY_TIMER_FLAG = 1;
 275   4              key_timer_com();        
 276   4            }
 277   3          }
 278   2        }
 279   1        else 
 280   1        {
 281   2          if((exKeyValueFlag & 0x000000020) == 0x000000000)
 282   2          {
 283   3            KEY_TIMER_FLAG = 0;
 284   3            key_timer_count = 0;
 285   3          }
 286   2        }
 287   1      }
 288          
 289          void key_ion_com(void)
 290          {
 291   1        ION_PIN = !ION_PIN;
 292   1        set_beep_count(10);
 293   1        //fan_pulse_count_add();
 294   1      }
 295          
 296          void reset_lock_flag(void)
 297          {
 298   1        LOCK_FLAG = 0;
 299   1        reset_key_no_move_count();
 300   1        set_beep_count(10);
 301   1      }
C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 6   

 302          
 303          void key_timer_com(void)
 304          {
 305   1        regulate_timing_off_level();
 306   1        set_beep_count(10);
 307   1      }
 308          
 309          void key_arom_com(void)
 310          {
 311   1        regulate_arom_level();
 312   1        set_beep_count(10);
 313   1        //fan_pulse_count_dec();
 314   1      }
 315          
 316          void key_power_speed_com(void)
 317          {
 318   1        regulate_fan_speed();//速度加1
 319   1        write_speed_to_eeprom();//写入eeprom
 320   1        set_beep_count(10);
 321   1      }
 322          
 323          void key_lock_com(void)
 324          {
 325   1        //P52 = ~P52;
 326   1        //UNLOCk_FLAG = ~UNLOCk_FLAG;
 327   1        //LOCK_FLAG = ~LOCK_FLAG;      //解
 328   1        reset_lock_flag();  
 329   1        
 330   1      }
 331          unsigned char read_lock_flag(void)
 332          {
 333   1        return LOCK_FLAG;
 334   1      }
 335          
 336          void key_speed_com(void)
 337          {
 338   1        regulate_fan_speed();
 339   1        set_beep_count(10);
 340   1        
 341   1      }
 342          
 343          void key_power_long_com(void)
 344          //长按电源键清楚滤网寿命
 345          {
 346   1        reset_filter_time();
 347   1        set_beep_count(10);
 348   1      }
 349          
 350          //void key_sleep_com(void)
 351          //{ 
 352          //  P50 = ~P50;
 353          //  if(read_fan_speed() != 0) 
 354          //  {
 355          /////   set_fan_speed(0);
 356          //    //set_night_light_level(0);
 357          //    //led_key_sleep();
 358          //  }
 359          //  else 
 360          //  {
 361          ////    set_fan_speed(1);
 362          //    //led_key_speed();
 363          //  }
C51 COMPILER V9.52.0.0   KEY                                                               11/23/2019 21:21:28 PAGE 7   

 364          //  
 365          //}
 366          
 367          
 368          
 369          void key_power_com(void)
 370          {
 371   1        //unsigned long filter_time_temp;
 372   1        //P50 = ~P50;
 373   1        set_beep_count(10);
 374   1        if(POWER_ON_STATUS == read_power_status())
 375   1        {
 376   2          power_off();
 377   2          //if((read_filter_time()) & 0x000000ff == 0) led_power_on();
 378   2          
 379   2          //filter_time_temp = read_filter_time();
 380   2          //WDTCON  = 0x10;
 381   2          //IAPWrite(0x0f,(unsigned char)(filter_time_temp & 0x000000ff),IapEPPROM); 
 382   2          //IAPWrite(0x0f,0x20,IapEPPROM); 
 383   2          //IAPWrite(0x0f,31,IapEPPROM); 
 384   2          write_filter_time();
 385   2        }
 386   1        else
 387   1        {
 388   2          power_on();
 389   2        }
 390   1      }
 391          
 392          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    989    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
