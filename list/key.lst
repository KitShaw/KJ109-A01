C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\obj\key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\key.c BROWSE INCDIR(.\inc;.\lib) DEBUG OBJECTEXTEND PRINT(.\list\key.ls
                    -t) TABS(2) OBJECT(.\obj\key.obj)

line level    source

   1          
   2          
   3          /*
   4           * key.c
   5           */
   6          
   7          #include <key.h>
   8          #include "inc\SC92F844x_C.h"
   9          #include "data_type.h"
  10          #include "lib\SensorMethod.h"
  11          #include "fan.h"
  12          #include "led.h"
  13          #include "eeprom.h"
  14          #include "filter.h"
  15          #include "ion.h"
  16          #include "arom.h"
  17          #include "timing_off.h"
  18          #include "beep.h"
  19          
  20          
  21          bitval key_flag;
  22          bitval key_flag2;
  23          
  24          #define KEY_POWER_FLAG  key_flag.bit0
  25          #define KEY_AROM_FLAG key_flag.bit1   
  26          #define KEY_SPEED_FLAG  key_flag.bit2
  27          #define KEY_LOCK_FLAG key_flag.bit3
  28          #define LOCK_FLAG   key_flag.bit6            //童锁解锁标志, 0解锁, 1锁住
  29          #define KEY_ION_FLAG key_flag.bit4
  30          #define KEY_TIMER_FLAG key_flag.bit5
  31          #define KEY_POWER_SPEED_FLAG key_flag.bit7
  32          
  33          #define KEY_POWER_SPEED_FLAG2 key_flag2.bit0 
  34          #define KEY_POWER_SHORT_FLAG key_flag2.bit1
  35          #define KEY_SPEED_TIMER_FLAG key_flag2.bit2
  36          #define KEY_SPEED_AROM_FLAG key_flag2.bit3
  37          
  38          //按下电源和风速键后要等2个按键都释放在复位此位
  39          
  40          unsigned short key_speed_arom_count;
  41          unsigned short key_speed_timer_count;
  42          unsigned short key_power_count;
  43          unsigned short key_speed_count;
  44          unsigned short key_lock_count;
  45          unsigned short key_ion_count;
  46          unsigned short key_timer_count;
  47          unsigned short key_arom_count;
  48          unsigned short key_power_speed_count;
  49          unsigned short power_up_20s_count;  //上电20s计数, 20秒内可以查看版本号
  50          
  51          unsigned long xdata key_no_move_count;      //按键没要按下计数, 如果一分钟没有动作,童锁就锁住
  52          
  53          
  54          INT32U exKeyValueFlag = 0;    //当前轮按键标志
C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 2   

  55          
  56          
  57          /**************************************************
  58          *函数名称：void  Sys_Scan(void) 
  59          *函数功能：扫描TK和显示
  60          *入口参数：void
  61          *出口参数：void  
  62          **************************************************/
  63          void Sys_Scan(void)
  64          {             
  65   1        if(SOCAPI_TouchKeyStatus&0x80)      //重要步骤2:  触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标
             -志位置起后
  66   1         {                                      
  67   2          SOCAPI_TouchKeyStatus &= 0x7f;  //重要步骤3: 清除标志位， 需要外部清除。                              
  68   2          exKeyValueFlag = TouchKeyScan();//按键数据处理函数    
  69   2          if((exKeyValueFlag & 0x0000031e0) != 0)reset_key_no_move_count(); //有键按下就复位按键计数值
  70   2          TouchKeyRestart();        //启动下一轮转换                                                                  
  71   2        }          
  72   1      }
  73          
  74          void key_init(void)
  75          {
  76   1        LOCK_FLAG = 0;  
  77   1        reset_key_no_move_count();
  78   1        //KEY_AROM_SPEED_TIMER_FLAG = 0;
  79   1        KEY_POWER_FLAG = 0;
  80   1        KEY_AROM_FLAG = 0;
  81   1        KEY_SPEED_FLAG = 0;
  82   1        KEY_LOCK_FLAG = 0;
  83   1        LOCK_FLAG = 0;            //童锁解锁标志, 0解锁, 1锁住
  84   1        KEY_ION_FLAG = 0;
  85   1        KEY_TIMER_FLAG = 0;
  86   1        KEY_POWER_SPEED_FLAG = 0;
  87   1        KEY_POWER_SPEED_FLAG2  = 0;
  88   1        KEY_POWER_SHORT_FLAG = 0;
  89   1        KEY_SPEED_TIMER_FLAG = 0;
  90   1        power_up_20s_count = 0;
  91   1      }
  92          
  93          void reset_key_no_move_count(void)
  94          {
  95   1        key_no_move_count = 0;
  96   1      }
  97          
  98          //0x0100--power
  99          //0x2000--香薰
 100          //0x1000--ion
 101          //0x0080--模式
 102          //0x0040--童锁
 103          //0x0020--timer
 104          //0x31e0
 105          
 106          void key_task(void)       
 107          //按键任务, 1ms调用一次
 108          { 
 109   1        if(key_no_move_count >= 180000)
 110   1        {
 111   2          LOCK_FLAG = 1; 
 112   2        }
 113   1        else
 114   1        {
 115   2          //reset_key_no_move_count();
C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 3   

 116   2          if(POWER_ON_STATUS == read_power_status())key_no_move_count++;
 117   2        }
 118   1        
 119   1      
 120   1        
 121   1      
 122   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000100) && (0 == KEY_POWER_SPEED_FLAG2)
 123   1          && (0 == LOCK_FLAG))//电源键  //灵敏度不够
 124   1        {
 125   2          if(0 == KEY_POWER_FLAG)
 126   2          {     
 127   3            if(++key_power_count >= 5000)
 128   3            {
 129   4              KEY_POWER_FLAG = 1;   
 130   4              key_power_long_com();
 131   4            }
 132   3          }
 133   2        }
 134   1        else 
 135   1        {
 136   2          //if((exKeyValueFlag & 0x0000031e0) != 0x000000180) 
 137   2          if((exKeyValueFlag & 0x0000031e0) == 0) 
 138   2          {
 139   3            if((key_power_count>50) && (key_power_count< 5000) )//&& ( 0 == KEY_POWER_SHORT_FLAG))
 140   3            {
 141   4              //KEY_POWER_SHORT_FLAG = 1;
 142   4              key_power_com();
 143   4            }
 144   3          }
 145   2          //if((exKeyValueFlag & 0x0000031e0) == 0x000000000) KEY_POWER_SHORT_FLAG = 0;
 146   2          KEY_POWER_FLAG = 0;
 147   2          key_power_count = 0;
 148   2          
 149   2        }
 150   1        
 151   1        if(power_up_20s_count < 20000) power_up_20s_count++;
 152   1        
 153   1        if(read_power_status() == POWER_OFF_STATUS)
 154   1        {
 155   2          if(((exKeyValueFlag & 0x0000031e0) == 0x0000002080) )  //80(s 2000a 20t
 156   2          {
 157   3            if(0 == KEY_SPEED_AROM_FLAG)
 158   3            {
 159   4              if(++key_speed_arom_count >= 5000)
 160   4                //显示软件版本号
 161   4              {
 162   5                KEY_SPEED_AROM_FLAG = 1;
 163   5                chang_init_up_power();  //改变上电初始状态
 164   5              }
 165   4            }     
 166   3          }
 167   2          else
 168   2          {
 169   3            key_speed_arom_count = 0;
 170   3            KEY_SPEED_AROM_FLAG = 0;
 171   3          }
 172   2      
 173   2          if(((exKeyValueFlag & 0x0000031e0) == 0x0000000a0) && (power_up_20s_count<20000))  //80(s 2000a 20t
 174   2          {
 175   3            if(0 == KEY_SPEED_TIMER_FLAG)
 176   3            {
 177   4              if(++key_speed_timer_count >= 15000)
C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 4   

 178   4                //显示软件版本号
 179   4              {
 180   5                KEY_SPEED_TIMER_FLAG = 1;
 181   5                led_display_version();
 182   5              }
 183   4            }
 184   3            
 185   3          }
 186   2          
 187   2          return; //关机状态直接返回
 188   2        }
 189   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000180) && (0 == LOCK_FLAG))
 190   1        //风速加电源按键
 191   1        {
 192   2          if(0 == KEY_POWER_SPEED_FLAG)
 193   2          {     
 194   3            if(++key_power_speed_count >= 50)
 195   3            {
 196   4              KEY_POWER_SPEED_FLAG = 1; 
 197   4              KEY_POWER_SPEED_FLAG2 = 1;
 198   4              key_power_speed_com();
 199   4            }
 200   3          }
 201   2        }
 202   1        else 
 203   1        {   
 204   2          if(((exKeyValueFlag & 0x000000180) == 0)) KEY_POWER_SPEED_FLAG2 = 0;
 205   2          KEY_POWER_SPEED_FLAG = 0;
 206   2          key_power_speed_count = 0;
 207   2        }
 208   1        
 209   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000080)&& (0 == KEY_POWER_SPEED_FLAG2)
 210   1          && (0 == LOCK_FLAG) )//风速键 
 211   1        {
 212   2          if(0 == KEY_SPEED_FLAG)
 213   2          {
 214   3            if(++key_speed_count >= 50)
 215   3            {
 216   4              KEY_SPEED_FLAG = 1;
 217   4              key_speed_com();
 218   4            }
 219   3          }
 220   2        }
 221   1        else 
 222   1        {
 223   2          if((exKeyValueFlag & 0x000000080) == 0)
 224   2          {
 225   3            KEY_SPEED_FLAG = 0;
 226   3            key_speed_count = 0;
 227   3          }
 228   2        }
 229   1        
 230   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000001000) && (0 == LOCK_FLAG))//ion
 231   1        {
 232   2          if(0 == KEY_ION_FLAG)
 233   2          {
 234   3            if(++key_ion_count >= 50)
 235   3            {
 236   4              KEY_ION_FLAG = 1;
 237   4              key_ion_com();        
 238   4            }
 239   3          }
C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 5   

 240   2        }
 241   1        else 
 242   1        {
 243   2          if((exKeyValueFlag & 0x000001000) == 0)
 244   2          {
 245   3            KEY_ION_FLAG = 0;
 246   3            key_ion_count = 0;
 247   3          }
 248   2        }
 249   1        
 250   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000002000) && (0 == LOCK_FLAG))//arom
 251   1        {
 252   2          if(0 == KEY_AROM_FLAG)
 253   2          {
 254   3            if(++key_arom_count >= 50)
 255   3            {
 256   4              KEY_AROM_FLAG = 1;
 257   4              key_arom_com();       
 258   4            }
 259   3          }
 260   2        }
 261   1        else 
 262   1        {
 263   2          if((exKeyValueFlag & 0x000002000) == 0)
 264   2          {
 265   3            KEY_AROM_FLAG = 0;
 266   3            key_arom_count = 0;
 267   3          }
 268   2        }
 269   1          
 270   1        if((exKeyValueFlag & 0x0000031e0) == 0x000000040)//
 271   1        {
 272   2          if(0 == KEY_LOCK_FLAG)
 273   2          {
 274   3            if(++key_lock_count >= 3000)
 275   3            {
 276   4              KEY_LOCK_FLAG = 1;
 277   4              //set_beep_count(10);
 278   4              key_lock_com();       
 279   4            }
 280   3          }
 281   2        }
 282   1        else 
 283   1        {
 284   2          if((exKeyValueFlag & 0x000000040) == 0x000000000)
 285   2          {
 286   3            KEY_LOCK_FLAG = 0;
 287   3            key_lock_count = 0;
 288   3          }
 289   2        }
 290   1        if(((exKeyValueFlag & 0x0000031e0) == 0x000000020) && (0 == LOCK_FLAG))//
 291   1        {
 292   2          if(0 == KEY_TIMER_FLAG)
 293   2          {
 294   3            if(++key_timer_count >= 50)
 295   3            {
 296   4              KEY_TIMER_FLAG = 1;
 297   4              key_timer_com();        
 298   4            }
 299   3          }
 300   2        }
 301   1        else 
C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 6   

 302   1        {
 303   2          if((exKeyValueFlag & 0x000000020) == 0x000000000)
 304   2          {
 305   3            KEY_TIMER_FLAG = 0;
 306   3            key_timer_count = 0;
 307   3          }
 308   2        }
 309   1      }
 310          
 311          void key_ion_com(void)
 312          {
 313   1        ION_PIN = !ION_PIN;
 314   1        set_beep_count(10);
 315   1        //fan_pulse_count_add();
 316   1      }
 317          
 318          void reset_lock_flag(void)
 319          {
 320   1        LOCK_FLAG = 0;
 321   1        reset_key_no_move_count();
 322   1        set_beep_count(10);
 323   1      }
 324          
 325          void key_timer_com(void)
 326          {
 327   1        regulate_timing_off_level();
 328   1        set_beep_count(10);
 329   1      }
 330          
 331          void key_arom_com(void)
 332          {
 333   1        regulate_arom_level();
 334   1        set_beep_count(10);
 335   1        //fan_pulse_count_dec();
 336   1      }
 337          
 338          void key_power_speed_com(void)
 339          {
 340   1        regulate_fan_speed();//速度加1
 341   1        write_speed_to_eeprom();//写入eeprom
 342   1        set_beep_count(10);
 343   1      }
 344          
 345          void key_lock_com(void)
 346          {
 347   1        //P52 = ~P52;
 348   1        //UNLOCk_FLAG = ~UNLOCk_FLAG;
 349   1        //LOCK_FLAG = ~LOCK_FLAG;      //解
 350   1        reset_lock_flag();  
 351   1        
 352   1      }
 353          unsigned char read_lock_flag(void)
 354          {
 355   1        return LOCK_FLAG;
 356   1      }
 357          
 358          void key_speed_com(void)
 359          {
 360   1        regulate_fan_speed();
 361   1        set_beep_count(10);
 362   1        
 363   1      }
C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 7   

 364          
 365          void key_power_long_com(void)
 366          //长按电源键清楚滤网寿命
 367          {
 368   1        reset_filter_time();
 369   1        set_beep_count(10);
 370   1      }
 371          
 372          //void key_sleep_com(void)
 373          //{ 
 374          //  P50 = ~P50;
 375          //  if(read_fan_speed() != 0) 
 376          //  {
 377          /////   set_fan_speed(0);
 378          //    //set_night_light_level(0);
 379          //    //led_key_sleep();
 380          //  }
 381          //  else 
 382          //  {
 383          ////    set_fan_speed(1);
 384          //    //led_key_speed();
 385          //  }
 386          //  
 387          //}
 388          
 389          
 390          
 391          void key_power_com(void)
 392          {
 393   1        //unsigned long filter_time_temp;
 394   1        //P50 = ~P50;
 395   1        set_beep_count(10);
 396   1        if(POWER_ON_STATUS == read_power_status())
 397   1        {
 398   2          power_off();
 399   2          //if((read_filter_time()) & 0x000000ff == 0) led_power_on();
 400   2          
 401   2          //filter_time_temp = read_filter_time();
 402   2          //WDTCON  = 0x10;
 403   2          //IAPWrite(0x0f,(unsigned char)(filter_time_temp & 0x000000ff),IapEPPROM); 
 404   2          //IAPWrite(0x0f,0x20,IapEPPROM); 
 405   2          //IAPWrite(0x0f,31,IapEPPROM); 
 406   2          write_filter_time();
 407   2        }
 408   1        else
 409   1        {
 410   2          power_on();
 411   2        }
 412   1      }
 413          
 414          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1069    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.52.0.0   KEY                                                               12/03/2019 23:42:28 PAGE 8   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
