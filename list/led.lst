C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE LED
OBJECT MODULE PLACED IN .\obj\led.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE src\led.c BROWSE INCDIR(.\inc;.\lib) DEBUG OBJECTEXTEND PRINT(.\list\led.ls
                    -t) TABS(2) OBJECT(.\obj\led.obj)

line level    source

   1          
   2          /*
   3           *  led.c
   4           *  Kit Shaw
   5           *  2019/10/01
   6           */
   7           
   8          
   9          #include "led.h"
  10          #include "SC92F844X_C.h"
  11          #include "data_type.h"
  12          #include "fan.h"
  13          #include "ion.h"
  14          #include "key.h"
  15          #include "dust.h"
  16          #include "arom.h"
  17          #include "timing_off.h"
  18          #include "intrins.h"
  19          
  20          unsigned char key_power_duty_count_flag;    //1加, 0减
  21          unsigned char key_power_duty_count;  //占空比
  22          unsigned char key_power_period;  //周期
  23          //unsigned char key_power_sum;       //计数总是,
  24          
  25          //unsigned char xdata LEDRAM[30] _at_ 0x700;
  26          
  27          unsigned int test_count;
  28          /*
  29          unsigned char leddata[]={ 
  30          
  31                          0x70,//0xc0,//0x3F,  //"0"  D7 =童锁右 (d6 d6)定时图标 
  32                          0x7f,//0xf9,//0x06,  //"1"  wifi图标(D7 D6) 自动(d5 d4) 睡眠(d3 d2) 童锁左(d1)
  33                          0x7f,//0xa4,//0x5B,  //"2"  40%右(D7) 60%(D6 D5) 80%(D4 D3) 100%(D2 D1)
  34                          0x7f,//0xb0,//0x4F,  //"3"  voc监测(D7 D6) 滤网寿命(D5 D4) 20%(D3 D2) 40%左(D1)
  35                          0x7f,//0x99, //0x66,  //"4" oC D7 湿度(D6) %(D5) 差(D4) 中(D3) 良(D2) 优(D1)
  36                          0x7f,//0x6D,  //"5"   // 定时(D7) PM2.5(D6) 风速(D5) 温度(D4) 小时(D3) ug/m3(D2) 分钟(D1)
  37                          0x73,//0x7D,  //"6"//湿度个位
  38                          0x7b,//0x07,  //"7" //湿度十位
  39                          0xb0,//0x7F,  //"8" //温度个位    //第8位VOC内圈红色LED
  40                          0xf9,//0x6F,  //"9" //温度十位    //第8位VOC内圈绿色LED
  41                          0x79,//0x77,  //"A" //pm25个位   //第8位VOC内圈蓝色LED
  42                          0xed,//0x7C,  //"B" //pm2.5十位  //第8位VOC外圈的蓝色led
  43                          0xb0,//0x39,  //"C" //pm2.5百位  //第8位VOC外圈的白色led背景
  44                          0xff,//0x5E,  //"D"
  45                          0xff,//0x79,  //"E"
  46                          0xff,//0x71,  //"F"
  47                          0xff,//0x76,  //"H"
  48                          0xff,//0x38,  //"L"
  49                          0xff,//0x37,  //"n"
  50                          0xff,//0x3E,  //"u"
  51                          0xff,//0x73,  //"P"
  52                          0xff,//0x5C,  //"o"
  53                          0xff,//0x40,  //"-"
  54                          0xff,//0x00,  //??
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 2   

  55                              };
  56          */
  57          
  58          void led_init(void)
  59          { 
  60   1        P5CON |= ((1<<0) | (1<<1)| (1<<2)); //
  61   1        //P5 &= ~((1<<0) | (1<<1)| (1<<2)); 
  62   1      
  63   1        P2CON |= 0x7f; //P2 out.
  64   1        LED_RED = 1;
  65   1        LED_GREEN = 1;
  66   1        LED_BLUE = 0;
  67   1      
  68   1        P3CON |= (1<<3) | (1<<4) | (1<<5) | (1<<6) | (1<<7); //P33, 34,35,35,37 out.
  69   1      
  70   1        P4CON |= (1<<0) | (1<<1) | (1<<6) | (1<<7);
  71   1        P0CON |= (1<<1) | (1<<5) | (1<<6);// | (1<<6) | (1<<7);
  72   1        P1CON |= (1<<6) | (1<<7);
  73   1      
  74   1        i2c_init();
  75   1        led_off();
  76   1        
  77   1      }
  78          
  79          void led_task(void)
  80          //100ms调用一次
  81          {
  82   1          if(read_power_status() == POWER_OFF_STATUS)
  83   1          {     
  84   2            return;
  85   2          }
  86   1          led_display_ion();
  87   1          led_display_arom_level();
  88   1          led_display_mode();
  89   1          led_display_lock();
  90   1        led_display_pm25();
  91   1        led_display_dust_level();
  92   1        led_display_timing_off_level();
  93   1        
  94   1      }
  95          
  96          void led_key_power_count(void)
  97          //做电源按键呼吸灯效果计数用
  98          {
  99   1        if(read_power_status() == POWER_OFF_STATUS)
 100   1        //关机是才呼吸灯
 101   1        {     
 102   2          if(++key_power_period >= LED_POWER_PERIOD) key_power_period = 0;
 103   2          if(key_power_duty_count>=key_power_period) LED_KEY_POWER = LED_ON;
 104   2          else LED_KEY_POWER = LED_OFF;
 105   2        }
 106   1      }
 107          
 108          void led_key_power(void)
 109          //10ms调用一次
 110          {
 111   1        if(read_power_status() == POWER_OFF_STATUS)
 112   1        //关机是才呼吸灯
 113   1        {   
 114   2          if(1 == key_power_duty_count_flag)key_power_duty_count++;
 115   2            else key_power_duty_count--;  
 116   2          if(key_power_duty_count >= LED_POWER_PERIOD) key_power_duty_count_flag = 0;
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 3   

 117   2          if(key_power_duty_count<=20) key_power_duty_count_flag = 1;   
 118   2        }
 119   1      }
 120          
 121          
 122          void led_display_filter_out(unsigned char filter_flag)
 123          {
 124   1        if( 1 == filter_flag) 
 125   1        {
 126   2        //LEDRAM[21] |= 0x10;  //滤网, 电源按键
 127   2          LED_FILTER = LED_ON;
 128   2        }
 129   1        else
 130   1        {
 131   2          //  LEDRAM[21] &= ~0x10;  //滤网, 电源按键
 132   2          LED_FILTER = LED_OFF;
 133   2        }
 134   1      }
 135          
 136          void led_off(void)
 137          {
 138   1        //DDRCON &= ~0x80;
 139   1        LED_GREEN = 1;
 140   1        LED_BLUE = 1;
 141   1        LED_RED = 1;
 142   1        LED_PM2_5 = 1;
 143   1        LED_TIMER_1H = 1;
 144   1        LED_TIMER_2H = 1; 
 145   1        LED_TIMER_4H = 1;
 146   1        LED_TIMER_8H = 1;
 147   1        LED_KEY_TIMER = 1;
 148   1        LED_FILTER = 1;
 149   1        LED_ION = 1;
 150   1        LED_KEY_ION  = 1;
 151   1        LED_KEY_AROM  = 1;
 152   1        LED_AROM_LOW = 1;
 153   1        LED_AROM_MIDDLE = 1;
 154   1        LED_AROM_HIGH  = 1;
 155   1        LED_SPEED_LOW = 1;
 156   1        LED_SPEED_MIDDLE = 1;
 157   1        LED_SPEED_HIGH = 1;
 158   1        LED_SPEED_AUTO = 1;
 159   1        LED_KEY_MODE = 1;
 160   1        LED_LOCK = 1;
 161   1        LED_KEY_LOCK = 1;
 162   1        LED_KEY_POWER = 1;
 163   1        tm1650_set(0x6E, 0x00);   //
 164   1        tm1650_set(0x6c, 0x00);   //
 165   1        tm1650_set(0x6A, 0x00);   //
 166   1        /*
 167   1        LEDRAM[11] &= ~0x08;  // 童锁图标
 168   1        LEDRAM[12] &= ~0x18;  //0x10 -P2.5  0x08-8H
 169   1        LEDRAM[13] &= ~0x18;  //0x10 - 高, 0x08 - 4H
 170   1        LEDRAM[14] &= ~0x18;  //0x10 - 中, 0x08 - 2H  
 171   1        //0x80 - 数码管百位的小数点,  0x40 十位, 0x20 个位
 172   1        LEDRAM[15] &= ~0xf8;  //0x10 - 低, 0x08 - 1H
 173   1        //数码管g段
 174   1        LEDRAM[16] &= ~0xf0;  //0x10 - ION图标, 0x08香薰按键,   
 175   1        //数码管F段
 176   1        LEDRAM[17] &= ~0xf0;   //0x10- 高速 和 0x08-负离子按键
 177   1        //数码管E段
 178   1        LEDRAM[18] &= ~0xf0;   //0x10- 中速 , 0x08 - 模式按键
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 4   

 179   1        //数码管D段
 180   1        LEDRAM[19] &= ~0xf0;  //低速 ,  童锁按键
 181   1        //数码管C段
 182   1        LEDRAM[20] &= ~0xf0;  //智能, 定时按键
 183   1        //数码管B段
 184   1        LEDRAM[21] &= ~0xf0;  //滤网, 电源按键
 185   1        //数码管A段
 186   1        */
 187   1      }
 188          
 189          void led_all_on(void)
 190          {
 191   1        //DDRCON &= ~0x80;
 192   1        LED_GREEN = 0;
 193   1        LED_BLUE = 0;
 194   1        LED_RED = 0;
 195   1      
 196   1        LED_PM2_5 = 0;
 197   1        LED_TIMER_1H = 0;
 198   1        LED_TIMER_2H = 0; 
 199   1        LED_TIMER_4H = 0;
 200   1        LED_FILTER = 0;
 201   1        LED_ION = 0;  
 202   1        LED_AROM_LOW = 0;
 203   1        LED_AROM_MIDDLE = 0;
 204   1        LED_AROM_HIGH  = 0;
 205   1        LED_SPEED_LOW = 0;
 206   1        LED_SPEED_MIDDLE = 0;
 207   1        LED_SPEED_HIGH = 0;
 208   1        LED_SPEED_AUTO = 0;
 209   1        LED_LOCK = 0;
 210   1      
 211   1        LED_KEY_TIMER = 0;
 212   1        LED_KEY_MODE = 0; 
 213   1        LED_KEY_LOCK = 0;
 214   1        LED_KEY_POWER = 0;
 215   1        LED_KEY_ION  = 0;
 216   1        LED_KEY_AROM  = 0;
 217   1      
 218   1        tm1650_set(0x6E, 0xff);   //
 219   1        tm1650_set(0x6c, 0xff);   //
 220   1        tm1650_set(0x6A, 0xff);   //
 221   1      }
 222          
 223          
 224          void led_key_on(void)
 225            //开机后按键的灯亮起来
 226          {
 227   1        LED_KEY_TIMER = 0;
 228   1        LED_KEY_MODE = 0; 
 229   1        LED_KEY_LOCK = 0;
 230   1        LED_KEY_POWER = 0;
 231   1        LED_KEY_ION  = 0;
 232   1        LED_KEY_AROM  = 0;
 233   1      }
 234          
 235          
 236          void led_on(void)
 237          {
 238   1        //DDRCON |= 0x80;
 239   1      }
 240          
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 5   

 241          
 242          void led_display_pm25(void)
 243          {
 244   1        unsigned short tmp_dust_display_value;
 245   1        tmp_dust_display_value = read_dust_display_value();
 246   1        //led_display_bcd(tmp_dust_display_value / 100, HUNDRED_DIGIT);
 247   1        //led_display_bcd(tmp_dust_display_value % 100 / 10, TEN_DIGIT);
 248   1        //led_display_bcd(tmp_dust_display_value % 10, SINGLE_DIGIT);
 249   1      
 250   1        tm1650_set(0x6E, led_display_bcd(tmp_dust_display_value / 100));   //
 251   1        tm1650_set(0x6c, led_display_bcd(tmp_dust_display_value % 100 / 10));   //
 252   1        tm1650_set(0x6A, led_display_bcd(tmp_dust_display_value % 10));   //
 253   1        LED_PM2_5 = LED_ON; //PM2.5图标
 254   1      }
 255          
 256          void led_display_timing_off_level(void)
 257          {
 258   1        switch(read_timing_off_level())
 259   1        {
 260   2          //case 0:  //关闭
 261   2          //  LEDRAM[13] &= ~0x10;  //0x10 - 高, 0x08 - 4H
 262   2          //  LEDRAM[14] &= ~0x10;  //0x10 - 中, 0x08 - 2H  
 263   2            //0x80 - 数码管百位的小数点,  0x40 十位, 0x20 个位
 264   2          //  LEDRAM[15] &= ~0x10;  //0x10 - 低, 0x08 - 1H
 265   2          //break;
 266   2          case 1:  // 1H
 267   2            //LEDRAM[12] &= ~0x08;  //0x10 -P2.5  0x08-8H
 268   2            //LEDRAM[13] &= ~0x08;  //0x10 - 高, 0x08 - 4H
 269   2            //LEDRAM[14] &= ~0x08;  //0x10 - 中, 0x08 - 2H  
 270   2            //LEDRAM[15] |= 0x08;  //0x10 - 低, 0x08 - 1H
 271   2            LED_TIMER_1H = LED_ON;
 272   2            LED_TIMER_2H = LED_OFF;
 273   2            LED_TIMER_4H = LED_OFF;
 274   2            LED_TIMER_8H = LED_OFF;
 275   2          break;
 276   2          case 2:  // 2H
 277   2            LED_TIMER_1H = LED_OFF;
 278   2            LED_TIMER_2H = LED_ON;
 279   2            LED_TIMER_4H = LED_OFF;
 280   2            LED_TIMER_8H = LED_OFF;
 281   2          break;
 282   2          case 3:  // 4H
 283   2            LED_TIMER_1H = LED_OFF;
 284   2            LED_TIMER_2H = LED_OFF;
 285   2            LED_TIMER_4H = LED_ON;
 286   2            LED_TIMER_8H = LED_OFF;
 287   2          break;
 288   2          case 4:  // 8H
 289   2            LED_TIMER_1H = LED_OFF;
 290   2            LED_TIMER_2H = LED_OFF;
 291   2            LED_TIMER_4H = LED_OFF;
 292   2            LED_TIMER_8H = LED_ON;
 293   2          break;
 294   2          default:
 295   2            LED_TIMER_1H = LED_OFF;
 296   2            LED_TIMER_2H = LED_OFF;
 297   2            LED_TIMER_4H = LED_OFF;
 298   2            LED_TIMER_8H = LED_OFF;
 299   2          break;
 300   2        }
 301   1      }
 302          
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 6   

 303          void led_display_arom_level(void)
 304          {
 305   1        switch(read_arom_level())
 306   1        {
 307   2          case 1:  //低
 308   2            LED_AROM_LOW= LED_ON;
 309   2            LED_AROM_MIDDLE= LED_OFF;
 310   2            LED_AROM_HIGH= LED_OFF;     
 311   2          break;
 312   2          case 2:  //中
 313   2            LED_AROM_LOW= LED_OFF;
 314   2            LED_AROM_MIDDLE= LED_ON;
 315   2            LED_AROM_HIGH= LED_OFF; 
 316   2          break;
 317   2          case 3:  //高
 318   2            LED_AROM_LOW= LED_OFF;
 319   2            LED_AROM_MIDDLE= LED_OFF;
 320   2            LED_AROM_HIGH= LED_ON;  
 321   2          break;
 322   2          default:
 323   2            LED_AROM_LOW= LED_OFF;
 324   2            LED_AROM_MIDDLE= LED_OFF;
 325   2            LED_AROM_HIGH= LED_OFF; 
 326   2          break;
 327   2        }
 328   1      }
 329          
 330          void led_display_dust_level(void)
 331          {
 332   1        switch(read_dust_level())
 333   1        {
 334   2          case DUST_LEVEL_EXCELLENT:
 335   2            LED_GREEN = 0;
 336   2            LED_BLUE = 1;
 337   2            LED_RED = 1;
 338   2          break;
 339   2          case DUST_LEVEL_12:
 340   2            LED_GREEN = 0;
 341   2            LED_BLUE = 0;
 342   2            LED_RED = 1;
 343   2          break;
 344   2          case DUST_LEVEL_MEDIUM:
 345   2            LED_GREEN = 0;
 346   2            LED_BLUE = 1;
 347   2            LED_RED = 0;
 348   2          break;
 349   2          /*
 350   2          case DUST_LEVEL_23:
 351   2            LED_GREEN = 1;
 352   2            LED_BLUE = 1;
 353   2            LED_RED = 0;
 354   2          break;
 355   2          */
 356   2          case DUST_LEVEL_BAD:
 357   2            LED_GREEN = 1;
 358   2            LED_BLUE = 1;
 359   2            LED_RED = 0;
 360   2          break;
 361   2          default:
 362   2            LED_GREEN = 0;
 363   2            LED_BLUE = 1;
 364   2            LED_RED = 1;
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 7   

 365   2          break;
 366   2        }
 367   1      }
 368          
 369          void led_display_lock(void)
 370          {
 371   1        if( 0 == read_lock_flag())
 372   1        {
 373   2          LED_LOCK = LED_OFF;
 374   2        }
 375   1        else
 376   1        {
 377   2          LED_LOCK = LED_ON;
 378   2        }
 379   1      }
 380          
 381          void led_display_ion(void)
 382          {
 383   1        if(0 == ION_PIN)
 384   1        {
 385   2          //LEDRAM[16] |= 0x10;  //0x10 - ION图标, 0x08香薰按键, 
 386   2          LED_ION = LED_ON;
 387   2        }
 388   1        else
 389   1        {
 390   2          LED_ION = LED_OFF;
 391   2          //LEDRAM[16] &= ~0x10;  //0x10 - ION图标, 0x08香薰按键, 
 392   2        }
 393   1      }
 394          
 395          void led_display_mode(void)
 396            //智能, 酒店, 中速, 超强
 397          {
 398   1        switch(read_fan_speed())
 399   1        {
 400   2          case FAN_SPEED_AUTO:
 401   2            LED_SPEED_AUTO = LED_ON;
 402   2            LED_SPEED_LOW = LED_OFF;
 403   2            LED_SPEED_MIDDLE= LED_OFF;
 404   2            LED_SPEED_HIGH= LED_OFF;
 405   2          break;
 406   2          case FAN_SPEED_SLEEP:
 407   2            LED_SPEED_AUTO = LED_OFF;
 408   2            LED_SPEED_LOW = LED_ON;
 409   2            LED_SPEED_MIDDLE= LED_OFF;
 410   2            LED_SPEED_HIGH= LED_OFF;
 411   2          break;
 412   2          case FAN_SPEED_MIDDLE:
 413   2            LED_SPEED_AUTO = LED_OFF;
 414   2            LED_SPEED_LOW = LED_OFF;
 415   2            LED_SPEED_MIDDLE= LED_ON;
 416   2            LED_SPEED_HIGH= LED_OFF;
 417   2          break;
 418   2          case FAN_SPEED_HIGH:
 419   2            LED_SPEED_AUTO = LED_OFF;
 420   2            LED_SPEED_LOW = LED_OFF;
 421   2            LED_SPEED_MIDDLE= LED_OFF;
 422   2            LED_SPEED_HIGH= LED_ON;
 423   2          break;
 424   2          default:
 425   2            LED_SPEED_AUTO = LED_OFF;
 426   2            LED_SPEED_LOW = LED_OFF;
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 8   

 427   2            LED_SPEED_MIDDLE= LED_OFF;
 428   2            LED_SPEED_HIGH= LED_OFF;
 429   2          break;
 430   2        }
 431   1      }
 432          
 433          unsigned char led_display_bcd(unsigned char bcd_value)
 434          // 返回的数据
 435          {
 436   1      //8-e 7-d 6-dp 5-c 4-g 3-b 2-f 1-a
 437   1        unsigned char tmp;
 438   1        switch(bcd_value)
 439   1        {
 440   2          case 0:
 441   2            //tmp = 0xaf;
 442   2            tmp = 0xd7;
 443   2          break;
 444   2          case 1:
 445   2            tmp = 0x14;
 446   2          break;
 447   2          case 2:
 448   2            tmp = 0xcd;
 449   2          break;
 450   2          case 3:
 451   2            tmp = 0x5d;
 452   2          break;
 453   2          case 4:
 454   2            tmp = 0x1e;
 455   2          break;
 456   2          case 5://a
 457   2            tmp = 0x5b;
 458   2          break;
 459   2          case 6:
 460   2            tmp = 0xdb;
 461   2          break;
 462   2          case 7:
 463   2            tmp = 0x15;
 464   2          break;
 465   2          case 8:
 466   2            tmp = 0xdf;
 467   2          break;
 468   2          case 9:
 469   2            tmp = 0x5f;
 470   2          break;
 471   2          default:
 472   2            tmp = 0x00;
 473   2          break;        
 474   2        }
 475   1        return tmp;
 476   1      }
 477          
 478          
 479          void i2c_init(void)
 480          {
 481   1        P0CON |= (1<<0);  //P00输出
 482   1        P2CON |= (1<<7);  //P27输出
 483   1        
 484   1        i2c_clk_low();
 485   1        i2c_din_high();
 486   1        tm1650_set(0x48, 0x05);   //开显示0段数码管,灰度1
 487   1        //test_i2c();
 488   1      }
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 9   

 489          
 490          void tm1650_set(unsigned char add,unsigned char dat) //数码管显示
 491          {
 492   1              //写显存必须从高地址开始写
 493   1              i2c_start();
 494   1              i2c_write_byte(add); //第一个显存地址
 495   1              i2c_waik_ack();
 496   1              i2c_write_byte(dat);
 497   1              i2c_waik_ack();
 498   1              i2c_stop();
 499   1      }
 500          
 501          
 502          void sda_mode(unsigned char mode)
 503            // 1输出, 0输入
 504          {
 505   1        if(IO_MODE_IN == mode)
 506   1        {
 507   2          P2CON &= ~(1<<7);  //P27输入
 508   2        }
 509   1        else
 510   1        {
 511   2          P2CON |= (1<<7);  //P27输出
 512   2        }
 513   1      }
 514          
 515          /*
 516          void test_i2c(void)
 517          {
 518            unsigned short i;
 519            unsigned char addr;
 520            //delay_ms(1000);
 521            for(i = 0; i< 10000; i++)WDTCON  = 0x10;
 522            i2c_start();
 523            //i2c_write_byte(0x80);  //写数据命令
 524            i2c_write_byte(0x48);  //写数据命令
 525            //i2c_stop();
 526            i2c_waik_ack();
 527            
 528            //for(i = 0; i<60; i++) WDTCON = 0x10;
 529            //i2c_start();
 530            
 531            i2c_write_byte(0x05);  //7段显示, 开显示
 532            i2c_waik_ack();
 533            i2c_stop();
 534            
 535            for(i = 0; i<60; i++) WDTCON = 0x10;
 536            i2c_start();
 537            addr = 0x68;
 538            i2c_write_byte(addr);  //设置地址命令00
 539            i2c_waik_ack();
 540            //i2c_write_byte(0xff);  //设置数据为0
 541            
 542            //for(i = 0; i<4; i++)
 543            //{
 544              
 545            //  i2c_write_byte(0x0f);  //写数据命令
 546            //}
 547            i2c_write_byte(0x0f);  //写数据命令
 548            i2c_waik_ack();
 549            i2c_stop();
 550          
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 10  

 551            for(i = 0; i<60; i++) WDTCON = 0x10;
 552            i2c_start();
 553            addr = 0x6A;
 554            i2c_write_byte(addr);  //设置地址命令00
 555            i2c_waik_ack();
 556            //i2c_write_byte(0xff);  //设置数据为0
 557            
 558            //for(i = 0; i<4; i++)
 559            //{
 560              
 561            //  i2c_write_byte(0x0f);  //写数据命令
 562            //}
 563            i2c_write_byte(0xaa);  //写数据命令
 564            i2c_waik_ack();
 565            i2c_stop(); 
 566          }
 567          */
 568          void delay_us(unsigned char val)
 569          {
 570   1        unsigned char i;
 571   1        for(i = 0; i < val; i++)
 572   1        {
 573   2          //_nop_();
 574   2          _nop_();
 575   2        }
 576   1      }
 577          
 578          
 579          void  i2c_waik_ack(void)
 580          {
 581   1         uchar EEPROM_err_count;
 582   1         
 583   1         //SDA_MODEL = 1; 
 584   1         delay_us(5);
 585   1         I2C_CLK = 1;    
 586   1         //I2C_DIN = 1;      
 587   1         delay_us(5); 
 588   1         I2C_CLK = 0;
 589   1         sda_mode(IO_MODE_IN);
 590   1         while( 1 == I2C_DIN)
 591   1         {
 592   2            EEPROM_err_count++;
 593   2            if(EEPROM_err_count>=240)
 594   2            {
 595   3               EEPROM_err_count=0;
 596   3               //EEPROM_err_flag=1;
 597   3               ION_PIN = ~ION_PIN;
 598   3           sda_mode(IO_MODE_OUT);
 599   3               break;
 600   3            }
 601   2         }     
 602   1         //SDA_MODEL = 0;  
 603   1         sda_mode(IO_MODE_OUT);
 604   1         //SCL = 0; 
 605   1         I2C_CLK = 0;
 606   1         //Delay1us();
 607   1         delay_us(5); 
 608   1         //I2C_DIN = 0;
 609   1         //SDA = 0; 
 610   1         
 611   1      }
 612          
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 11  

 613          
 614          void i2c_write_byte(unsigned char val)
 615            //写一个字节
 616          {
 617   1          unsigned char val_count;
 618   1          unsigned char write_data;
 619   1          write_data = val;
 620   1          delay_us(5);
 621   1          
 622   1          //i2c_din_low();
 623   1          i2c_clk_low();
 624   1          for(val_count = 0; val_count < 8; val_count++)
 625   1          {
 626   2            if((write_data & 0x80) > 0)
 627   2            {
 628   3              
 629   3              i2c_din_high();
 630   3              delay_us(5);
 631   3              i2c_clk_high();
 632   3              delay_us(5);
 633   3              i2c_clk_low();
 634   3              //i2c_din_low();
 635   3            }
 636   2            else
 637   2            {
 638   3              //i2c_clk_low();
 639   3              //i2c_delay();
 640   3              i2c_din_low();
 641   3              i2c_clk_high();
 642   3              delay_us(5);
 643   3              i2c_clk_low();
 644   3              //i2c_din_low();
 645   3            }
 646   2            write_data <<= 1;
 647   2          }
 648   1          //i2c_stop();
 649   1          delay_us(5);
 650   1          
 651   1      }
 652          
 653          void i2c_start(void)
 654          {
 655   1        i2c_din_high();
 656   1        //delay_5us(1);
 657   1        i2c_clk_high();
 658   1        delay_us(5);
 659   1        i2c_din_low();
 660   1        delay_us(5);
 661   1        i2c_clk_low();
 662   1        delay_us(5);
 663   1      }
 664          
 665          void i2c_stop(void)
 666          {
 667   1        i2c_din_low();
 668   1        //delay_5us(1);
 669   1        i2c_clk_high();
 670   1        delay_us(5);
 671   1        i2c_din_high();
 672   1        delay_us(5);
 673   1        i2c_clk_low();
 674   1        delay_us(5);
C51 COMPILER V9.52.0.0   LED                                                               10/20/2019 22:01:09 PAGE 12  

 675   1      }
 676          
 677          
 678          void i2c_clk_high(void)
 679          {
 680   1        //GPIO_SetBits(GPIOB, GPIO_Pin_5);   //将LED端口拉高，熄灭所有LED  clk
 681   1        I2C_CLK = 1;
 682   1      }
 683          
 684          void i2c_clk_low(void)
 685          {
 686   1        //GPIO_ResetBits(GPIOB, GPIO_Pin_5);   //将LED端口拉高，熄灭所有LED  clk
 687   1        I2C_CLK = 0;
 688   1      }
 689          
 690          void i2c_din_high(void)
 691          {
 692   1        //GPIO_SetBits(GPIOB, GPIO_Pin_4);   //将LED端口拉高，熄灭所有LED  clk
 693   1        I2C_DIN = 1;
 694   1      }
 695          
 696          void i2c_din_low(void)
 697          {
 698   1        //GPIO_ResetBits(GPIOB, GPIO_Pin_4);   //将LED端口拉高，熄灭所有LED  clk
 699   1        I2C_DIN = 0;
 700   1      }
 701          
 702          
 703          
 704          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    907    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
